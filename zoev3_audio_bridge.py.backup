#!/usr/bin/env python3
"""
Zoev4 -> Zoev3 éŸ³é¢‘æ¡¥æ¥æœåŠ¡å™¨
ç›´æ¥å‘è¿è¡Œä¸­çš„Zoev3å®ä¾‹æ³¨å…¥Webç«¯éŸ³é¢‘æ•°æ®
"""

import asyncio
import json
import logging
import sys
import os
import socket
import threading
import time
from pathlib import Path
from typing import Optional, Dict, Any
import numpy as np
import multiprocessing
import gc
import weakref
from collections import defaultdict

# WebSocketç›¸å…³å¯¼å…¥
try:
    from fastapi import FastAPI, WebSocket, WebSocketDisconnect
    from fastapi.responses import HTMLResponse
    import uvicorn
    import opuslib
    import aiohttp
    import requests
except ImportError as e:
    print(f"âŒ ç¼ºå°‘ä¾èµ–åŒ…: {e}")
    sys.exit(1)

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class Zoev3AudioBridge:
    """Zoev3éŸ³é¢‘æ¡¥æ¥å™¨"""

    def __init__(self):
        self.app = FastAPI(title="Zoev4 â†’ Zoev3 éŸ³é¢‘æ¡¥æ¥å™¨")
        self.opus_encoder = None
        self.active_connections = set()

        # Zoev3è¿›ç¨‹é€šä¿¡
        self.zoev3_process = None
        self.audio_injection_socket = None
        self.zoev3_app_instance = None

        # ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            'web_packets_received': 0,
            'opus_packets_created': 0,
            'zoev3_injections': 0,
            'start_time': time.time()
        }

        # å½•éŸ³ä¼šè¯ç®¡ç†
        self.recording_sessions = {}  # å­˜å‚¨æ¯ä¸ªè¿æ¥çš„å½•éŸ³ä¼šè¯
        import tempfile
        self.temp_dir = tempfile.mkdtemp(prefix="zoev4_recordings_")
        logger.info(f"ğŸ“ å½•éŸ³ä¸´æ—¶ç›®å½•: {self.temp_dir}")

        # WebSocketè¿æ¥ç®¡ç† - ä¸ºæ—¥å¿—è½¬å‘å’Œæ•°æ®è½¬å‘
        self.websocket_connections = {}  # client_addr -> websocket

        # Zoev3ç³»ç»Ÿç›‘å¬å’Œæ‹¦æˆª
        self.zoev3_message_interceptor = None
        self.intercepted_audio_data = []  # å­˜å‚¨æ‹¦æˆªçš„éŸ³é¢‘æ•°æ®
        self.conversation_data = {  # å­˜å‚¨å¯¹è¯æ•°æ®
            'stt_results': [],
            'llm_responses': [],
            'tts_messages': []
        }

        self.setup_routes()

    async def send_log_to_frontend(self, client_addr: str, log_message: str):
        """å‘é€æ—¥å¿—æ¶ˆæ¯åˆ°å‰ç«¯"""
        if client_addr in self.websocket_connections:
            try:
                websocket = self.websocket_connections[client_addr]
                log_msg = {
                    "type": "server_log",
                    "message": log_message,
                    "timestamp": time.time()
                }
                await websocket.send_text(json.dumps(log_msg))
            except Exception as e:
                logger.warning(f"å‘é€æ—¥å¿—åˆ°å‰ç«¯å¤±è´¥: {e}")

    def setup_routes(self):
        """è®¾ç½®è·¯ç”±"""

        @self.app.get("/")
        async def get_index():
            """è¿”å›æµ‹è¯•é¡µé¢"""
            with open("web_audio_test.html", "r", encoding="utf-8") as f:
                return HTMLResponse(content=f.read())

        @self.app.websocket("/ws/audio")
        async def websocket_audio_endpoint(websocket: WebSocket):
            """WebSocketéŸ³é¢‘æ•°æ®å¤„ç†ç«¯ç‚¹"""
            await self.handle_audio_websocket(websocket)

        @self.app.get("/status")
        async def get_status():
            """è·å–æ¡¥æ¥å™¨çŠ¶æ€"""
            return {
                "bridge_active": True,
                "zoev3_connection": self.check_zoev3_connection(),
                "opus_encoder_ready": self.opus_encoder is not None,
                "active_connections": len(self.active_connections),
                "web_clients_connected": len(self.websocket_connections),
                "conversation_messages": {
                    "stt_count": len(self.conversation_data['stt_results']),
                    "llm_count": len(self.conversation_data['llm_responses']),
                    "tts_count": len(self.conversation_data['tts_messages'])
                },
                "intercepted_audio_count": len(self.intercepted_audio_data),
                **self.stats,
                "runtime_seconds": round(time.time() - self.stats['start_time'], 2)
            }

        @self.app.post("/inject-test")
        async def test_injection():
            """æµ‹è¯•éŸ³é¢‘æ³¨å…¥åŠŸèƒ½"""
            success = await self.test_audio_injection()
            return {"injection_test": "success" if success else "failed"}

        @self.app.get("/conversation/history")
        async def get_conversation_history():
            """è·å–å¯¹è¯å†å²API"""
            return {
                "conversation_data": self.conversation_data,
                "audio_history_count": len(self.intercepted_audio_data),
                "total_messages": (
                    len(self.conversation_data['stt_results']) +
                    len(self.conversation_data['llm_responses']) +
                    len(self.conversation_data['tts_messages'])
                )
            }

        @self.app.delete("/conversation/history")
        async def clear_conversation_history():
            """æ¸…é™¤å¯¹è¯å†å²API"""
            self.conversation_data = {
                'stt_results': [],
                'llm_responses': [],
                'tts_messages': []
            }
            self.intercepted_audio_data = []
            return {"message": "å¯¹è¯å†å²å·²æ¸…é™¤"}

    def check_zoev3_connection(self) -> str:
        """æ£€æŸ¥Zoev3è¿æ¥çŠ¶æ€"""
        # å…ˆå°è¯•è·å–Applicationå®ä¾‹
        if self.get_zoev3_application_instance():
            return "connected"

        # æ£€æŸ¥æ˜¯å¦æœ‰pythonè¿›ç¨‹è¿è¡Œmain.py
        import psutil
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                cmdline = proc.info['cmdline']
                if (cmdline and
                    'python' in cmdline[0] and
                    'main.py' in ' '.join(cmdline)):
                    return "detected"
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        return "not_found"

    async def initialize_opus_encoder(self):
        """åˆå§‹åŒ–OPUSç¼–ç å™¨"""
        try:
            logger.info("ğŸµ åˆå§‹åŒ–OPUSç¼–ç å™¨...")

            self.opus_encoder = opuslib.Encoder(
                16000,  # 16kHz é‡‡æ ·ç‡
                1,      # å•å£°é“
                opuslib.APPLICATION_AUDIO
            )

            logger.info("âœ… OPUSç¼–ç å™¨åˆå§‹åŒ–æˆåŠŸ")
            return True

        except Exception as e:
            logger.error(f"âŒ OPUSç¼–ç å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
            return False

    def start_recording_session(self, client_id: str):
        """å¼€å§‹å½•éŸ³ä¼šè¯"""
        import uuid
        session_id = str(uuid.uuid4())[:8]
        session_data = {
            'session_id': session_id,
            'client_id': client_id,
            'start_time': time.time(),
            'opus_frames': [],
            'total_frames': 0,
            'total_bytes': 0
        }
        self.recording_sessions[client_id] = session_data
        logger.info(f"ğŸ¬ å¼€å§‹å½•éŸ³ä¼šè¯ [{session_id}] å®¢æˆ·ç«¯: {client_id}")
        return session_data

    def add_audio_frame(self, client_id: str, opus_data: bytes):
        """æ·»åŠ éŸ³é¢‘å¸§åˆ°å½•éŸ³ä¼šè¯"""
        if client_id in self.recording_sessions:
            session = self.recording_sessions[client_id]
            session['opus_frames'].append(opus_data)
            session['total_frames'] += 1
            session['total_bytes'] += len(opus_data)
            logger.debug(f"ğŸ“¦ æ·»åŠ éŸ³é¢‘å¸§åˆ°ä¼šè¯ [{session['session_id']}]: {len(opus_data)}å­—èŠ‚")

    async def end_recording_session(self, client_id: str):
        """ç»“æŸå½•éŸ³ä¼šè¯å¹¶ä¿å­˜æ–‡ä»¶"""
        if client_id not in self.recording_sessions:
            logger.warning(f"âš ï¸ å®¢æˆ·ç«¯ {client_id} æ²¡æœ‰æ´»è·ƒçš„å½•éŸ³ä¼šè¯")
            return None

        session = self.recording_sessions[client_id]
        session_id = session['session_id']
        duration = time.time() - session['start_time']

        try:
            # ä¿å­˜å½•éŸ³æ–‡ä»¶
            filename = f"recording_{session_id}_{int(time.time())}.opus"
            filepath = os.path.join(self.temp_dir, filename)

            with open(filepath, 'wb') as f:
                for opus_frame in session['opus_frames']:
                    f.write(opus_frame)

            # è¯¦ç»†ç»Ÿè®¡ä¿¡æ¯
            file_size = os.path.getsize(filepath)
            logger.info(f"âœ… å½•éŸ³ä¼šè¯ [{session_id}] å·²å®Œæˆ:")
            logger.info(f"   ğŸ“‚ æ–‡ä»¶: {filepath}")
            logger.info(f"   â±ï¸  æ—¶é•¿: {duration:.2f}ç§’")
            logger.info(f"   ğŸ“¦ å¸§æ•°: {session['total_frames']}")
            logger.info(f"   ğŸ’¾ å¤§å°: {file_size} å­—èŠ‚")
            logger.info(f"   ğŸµ æ ¼å¼: OPUS 60mså¸§ 16kHz å•å£°é“")

            # è¿”å›å½•éŸ³ä¿¡æ¯
            recording_info = {
                'session_id': session_id,
                'filepath': filepath,
                'filename': filename,
                'duration': duration,
                'frames': session['total_frames'],
                'size': file_size,
                'success': True
            }

            # æ¸…ç†ä¼šè¯
            del self.recording_sessions[client_id]

            return recording_info

        except Exception as e:
            logger.error(f"âŒ ä¿å­˜å½•éŸ³æ–‡ä»¶å¤±è´¥ [{session_id}]: {e}")
            # æ¸…ç†ä¼šè¯
            if client_id in self.recording_sessions:
                del self.recording_sessions[client_id]
            return {
                'session_id': session_id,
                'success': False,
                'error': str(e)
            }

    async def handle_audio_websocket(self, websocket: WebSocket):
        """å¤„ç†WebSocketéŸ³é¢‘è¿æ¥"""
        await websocket.accept()
        self.active_connections.add(websocket)
        client_addr = websocket.client.host if websocket.client else "unknown"

        # ä¿å­˜WebSocketè¿æ¥ç”¨äºæ—¥å¿—è½¬å‘
        self.websocket_connections[client_addr] = websocket

        logger.info(f"ğŸ”— æ–°çš„éŸ³é¢‘æ¡¥æ¥è¿æ¥: {client_addr}")

        try:
            # å‘é€æ¬¢è¿æ¶ˆæ¯
            welcome_msg = {
                "type": "bridge_welcome",
                "message": "Zoev3éŸ³é¢‘æ¡¥æ¥è¿æ¥å·²å»ºç«‹",
                "zoev3_status": self.check_zoev3_connection(),
                "features": {
                    "audio_bridge": True,
                    "conversation_monitoring": True,
                    "tts_interception": True,
                    "stt_forwarding": True,
                    "llm_forwarding": True
                }
            }
            await websocket.send_text(json.dumps(welcome_msg))
            logger.info(f"ğŸ“¤ å·²å‘é€æ¬¢è¿æ¶ˆæ¯ç»™å®¢æˆ·ç«¯: {client_addr}")

            # å‘é€åˆå§‹æ—¥å¿—æ¶ˆæ¯
            await self.send_log_to_frontend(client_addr, "ğŸ”— æ¡¥æ¥å™¨è¿æ¥å·²å»ºç«‹ï¼Œå‡†å¤‡æ¥æ”¶éŸ³é¢‘æ•°æ®")

            # éŸ³é¢‘æ•°æ®å¤„ç†å¾ªç¯
            while True:
                message = await websocket.receive()

                if message['type'] == 'websocket.receive':
                    if 'text' in message:
                        # å¤„ç†æ§åˆ¶æ¶ˆæ¯
                        try:
                            control_msg = json.loads(message['text'])
                            if control_msg.get('type') == 'start_recording':
                                session = self.start_recording_session(client_addr)

                                # å‘é€æ§åˆ¶æ¶ˆæ¯åˆ°Zoev3è®©å…¶è‡ªåŠ¨å¼€å§‹å½•éŸ³
                                try:
                                    control_data = json.dumps({'type': 'start_recording'}).encode('utf-8')
                                    headers = {'Content-Type': 'application/json'}
                                    response_zoev3 = requests.post('http://localhost:8890/audio',
                                                                  data=control_data, headers=headers, timeout=5)
                                    logger.info(f"ğŸ¬ å·²å‘é€å¼€å§‹å½•éŸ³æ§åˆ¶ä¿¡å·åˆ°Zoev3: {response_zoev3.status_code}")
                                except Exception as e:
                                    logger.error(f"âŒ å‘é€å¼€å§‹å½•éŸ³æ§åˆ¶ä¿¡å·å¤±è´¥: {e}")

                                response = {
                                    'type': 'recording_started',
                                    'session_id': session['session_id']
                                }
                                await websocket.send_text(json.dumps(response))
                            elif control_msg.get('type') == 'stop_recording':
                                # å‘é€æ§åˆ¶æ¶ˆæ¯åˆ°Zoev3è®©å…¶è‡ªåŠ¨åœæ­¢å½•éŸ³
                                try:
                                    control_data = json.dumps({'type': 'stop_recording'}).encode('utf-8')
                                    headers = {'Content-Type': 'application/json'}
                                    response_zoev3 = requests.post('http://localhost:8890/audio',
                                                                  data=control_data, headers=headers, timeout=5)
                                    logger.info(f"â¹ï¸ å·²å‘é€åœæ­¢å½•éŸ³æ§åˆ¶ä¿¡å·åˆ°Zoev3: {response_zoev3.status_code}")
                                except Exception as e:
                                    logger.error(f"âŒ å‘é€åœæ­¢å½•éŸ³æ§åˆ¶ä¿¡å·å¤±è´¥: {e}")

                                recording_info = await self.end_recording_session(client_addr)
                                response = {
                                    'type': 'recording_stopped',
                                    'recording': recording_info
                                }
                                await websocket.send_text(json.dumps(response))
                            elif control_msg.get('type') == 'get_conversation_history':
                                # è·å–å¯¹è¯å†å²
                                history = {
                                    'type': 'conversation_history',
                                    'data': self.conversation_data,
                                    'audio_history_count': len(self.intercepted_audio_data)
                                }
                                await websocket.send_text(json.dumps(history))
                            elif control_msg.get('type') == 'clear_conversation_history':
                                # æ¸…é™¤å¯¹è¯å†å²
                                self.conversation_data = {
                                    'stt_results': [],
                                    'llm_responses': [],
                                    'tts_messages': []
                                }
                                self.intercepted_audio_data = []
                                response = {
                                    'type': 'conversation_cleared',
                                    'message': 'å¯¹è¯å†å²å·²æ¸…é™¤'
                                }
                                await websocket.send_text(json.dumps(response))
                        except json.JSONDecodeError:
                            logger.warning(f"âš ï¸ æ— æ•ˆçš„æ§åˆ¶æ¶ˆæ¯: {message['text']}")
                    elif 'bytes' in message:
                        # å¤„ç†éŸ³é¢‘æ•°æ®
                        audio_data = message['bytes']
                        logger.debug(f"ğŸµ ä» {client_addr} æ¥æ”¶åˆ°éŸ³é¢‘æ•°æ®: {len(audio_data)} å­—èŠ‚")
                        await self.process_and_inject_audio(audio_data, websocket, client_addr)

        except WebSocketDisconnect:
            logger.info(f"ğŸ”Œ éŸ³é¢‘æ¡¥æ¥è¿æ¥æ–­å¼€: {client_addr}")
        except Exception as e:
            logger.error(f"âŒ éŸ³é¢‘æ¡¥æ¥å¤„ç†é”™è¯¯: {e}")
            import traceback
            logger.error(f"âŒ è¯¦ç»†é”™è¯¯ä¿¡æ¯: {traceback.format_exc()}")
        finally:
            self.active_connections.discard(websocket)
            # æ¸…ç†WebSocketè¿æ¥è®°å½•
            if client_addr in self.websocket_connections:
                del self.websocket_connections[client_addr]

    async def process_and_inject_audio(self, audio_data: bytes, websocket: WebSocket, client_addr: str):
        """å¤„ç†éŸ³é¢‘æ•°æ®å¹¶æ³¨å…¥åˆ°Zoev3"""
        try:
            self.stats['web_packets_received'] += 1

            # è½¬æ¢éŸ³é¢‘æ•°æ®
            pcm_data = np.frombuffer(audio_data, dtype=np.int16)

            if len(pcm_data) < 960:  # æœ€å°å¸§å¤§å°æ£€æŸ¥ (60ms @ 16kHz)
                return

            # OPUSç¼–ç 
            if self.opus_encoder:
                frame_size = min(len(pcm_data), 960)  # 60mså¸§
                frame_data = pcm_data[:frame_size]
                pcm_bytes = frame_data.astype(np.int16).tobytes()

                try:
                    opus_data = self.opus_encoder.encode(pcm_bytes, frame_size)
                    if opus_data:
                        self.stats['opus_packets_created'] += 1

                        # å¦‚æœæœ‰æ´»è·ƒçš„å½•éŸ³ä¼šè¯ï¼Œä¿å­˜OPUSæ•°æ®
                        if client_addr in self.recording_sessions:
                            self.add_audio_frame(client_addr, opus_data)

                        # æ³¨å…¥åˆ°Zoev3
                        injection_success = await self.inject_to_zoev3(opus_data)

                        if injection_success:
                            self.stats['zoev3_injections'] += 1

                        # å‘é€è¯¦ç»†çš„å¤„ç†æ—¥å¿—åˆ°å‰ç«¯
                        await self.send_log_to_frontend(
                            client_addr,
                            f"ğŸµ OPUSç¼–ç æˆåŠŸ: {len(opus_data)}å­—èŠ‚ | æ³¨å…¥ç»“æœ: {'âœ…' if injection_success else 'âŒ'}"
                        )

                        # æ¯50åŒ…å‘é€ä¸€æ¬¡çŠ¶æ€æ›´æ–°
                        if self.stats['opus_packets_created'] % 50 == 0:
                            status_msg = {
                                "type": "bridge_status",
                                "opus_packets": self.stats['opus_packets_created'],
                                "zoev3_injections": self.stats['zoev3_injections'],
                                "injection_success": injection_success
                            }
                            await websocket.send_text(json.dumps(status_msg))
                            await self.send_log_to_frontend(
                                client_addr,
                                f"ğŸ“Š çŠ¶æ€æ›´æ–°: OPUSåŒ…={self.stats['opus_packets_created']}, æ³¨å…¥æˆåŠŸ={self.stats['zoev3_injections']}"
                            )

                except Exception as e:
                    logger.warning(f"âš ï¸ OPUSç¼–ç å¤±è´¥: {e}")

        except Exception as e:
            logger.error(f"âŒ éŸ³é¢‘å¤„ç†å’Œæ³¨å…¥å¤±è´¥: {e}")

    def get_zoev3_application_instance(self):
        """è·å–è¿è¡Œä¸­çš„Zoev3 Applicationå®ä¾‹"""
        if self.zoev3_app_instance:
            return self.zoev3_app_instance

        try:
            # é€šè¿‡gcæŸ¥æ‰¾Applicationå®ä¾‹
            for obj in gc.get_objects():
                if hasattr(obj, '__class__') and obj.__class__.__name__ == 'Application':
                    # æ£€æŸ¥æ˜¯å¦æ˜¯Zoev3çš„Applicationå®ä¾‹
                    if (hasattr(obj, '_on_encoded_audio') and
                        hasattr(obj, 'audio_codec') and
                        obj.audio_codec is not None):
                        self.zoev3_app_instance = obj
                        logger.info("âœ… æ‰¾åˆ°Zoev3 Applicationå®ä¾‹")
                        return obj
        except Exception as e:
            logger.warning(f"âš ï¸ æœç´¢Zoev3å®ä¾‹å¤±è´¥: {e}")

        return None

    def setup_zoev3_monitoring(self):
        """è®¾ç½®Zoev3ç³»ç»Ÿç›‘å¬å’Œæ‹¦æˆª"""
        try:
            app_instance = self.get_zoev3_application_instance()
            if app_instance:
                # ä¿å­˜åŸå§‹æ–¹æ³•çš„å¼•ç”¨
                original_handle_tts = getattr(app_instance, '_handle_tts_message', None)
                original_handle_stt = getattr(app_instance, '_handle_stt_message', None)
                original_handle_llm = getattr(app_instance, '_handle_llm_response', None)
                original_on_incoming_audio = getattr(app_instance, '_on_incoming_audio', None)

                # åˆ›å»ºæ‹¦æˆªæ–¹æ³•
                async def intercepted_handle_tts(data):
                    """æ‹¦æˆªTTSæ¶ˆæ¯"""
                    logger.info(f"ğŸ¤ æ‹¦æˆªåˆ°TTSæ¶ˆæ¯: {data}")
                    self.conversation_data['tts_messages'].append({
                        'timestamp': time.time(),
                        'data': data
                    })

                    # è½¬å‘ç»™Webç«¯
                    await self.broadcast_to_web_clients({
                        'type': 'tts_message',
                        'data': data,
                        'timestamp': time.time()
                    })

                    # è°ƒç”¨åŸå§‹æ–¹æ³•
                    if original_handle_tts:
                        return await original_handle_tts(data)

                async def intercepted_handle_stt(data):
                    """æ‹¦æˆªSTTæ¶ˆæ¯"""
                    logger.info(f"ğŸ¤ æ‹¦æˆªåˆ°STTæ¶ˆæ¯: {data}")
                    self.conversation_data['stt_results'].append({
                        'timestamp': time.time(),
                        'data': data
                    })

                    # è½¬å‘ç»™Webç«¯
                    await self.broadcast_to_web_clients({
                        'type': 'stt_result',
                        'data': data,
                        'timestamp': time.time()
                    })

                    # è°ƒç”¨åŸå§‹æ–¹æ³•
                    if original_handle_stt:
                        return await original_handle_stt(data)

                async def intercepted_handle_llm(data):
                    """æ‹¦æˆªLLMå“åº”"""
                    logger.info(f"ğŸ¤– æ‹¦æˆªåˆ°LLMå“åº”: {data}")
                    self.conversation_data['llm_responses'].append({
                        'timestamp': time.time(),
                        'data': data
                    })

                    # è½¬å‘ç»™Webç«¯
                    await self.broadcast_to_web_clients({
                        'type': 'llm_response',
                        'data': data,
                        'timestamp': time.time()
                    })

                    # è°ƒç”¨åŸå§‹æ–¹æ³•
                    if original_handle_llm:
                        return await original_handle_llm(data)

                def intercepted_on_incoming_audio(data):
                    """æ‹¦æˆªéŸ³é¢‘æ’­æ”¾æ•°æ®"""
                    logger.info(f"ğŸ”Š æ‹¦æˆªåˆ°éŸ³é¢‘æ•°æ®: {len(data)} å­—èŠ‚")

                    # å­˜å‚¨éŸ³é¢‘æ•°æ®
                    self.intercepted_audio_data.append({
                        'timestamp': time.time(),
                        'data': data,
                        'size': len(data)
                    })

                    # è½¬å‘éŸ³é¢‘æ•°æ®ç»™Webç«¯
                    asyncio.create_task(self.broadcast_audio_to_web_clients(data))

                    # é˜»æ­¢åŸå§‹éŸ³é¢‘æ’­æ”¾ - å…³é”®ä¿®æ”¹ç‚¹
                    logger.info("ğŸš« é˜»æ­¢Zoev3æœ¬åœ°éŸ³é¢‘æ’­æ”¾ï¼Œè½¬å‘åˆ°Webç«¯")
                    # ä¸è°ƒç”¨åŸå§‹æ–¹æ³•ï¼ŒéŸ³é¢‘å°†åœ¨Webç«¯æ’­æ”¾
                    return

                # æ›¿æ¢æ–¹æ³•
                if original_handle_tts:
                    app_instance._handle_tts_message = intercepted_handle_tts
                    logger.info("âœ… å·²è®¾ç½®TTSæ¶ˆæ¯æ‹¦æˆª")

                if original_handle_stt:
                    app_instance._handle_stt_message = intercepted_handle_stt
                    logger.info("âœ… å·²è®¾ç½®STTæ¶ˆæ¯æ‹¦æˆª")

                if original_handle_llm:
                    app_instance._handle_llm_response = intercepted_handle_llm
                    logger.info("âœ… å·²è®¾ç½®LLMå“åº”æ‹¦æˆª")

                if original_on_incoming_audio:
                    app_instance._on_incoming_audio = intercepted_on_incoming_audio
                    logger.info("âœ… å·²è®¾ç½®éŸ³é¢‘æ’­æ”¾æ‹¦æˆª")

                return True
        except Exception as e:
            logger.error(f"âŒ è®¾ç½®Zoev3ç›‘å¬å¤±è´¥: {e}")
        return False

    async def broadcast_to_web_clients(self, message: dict):
        """å¹¿æ’­æ¶ˆæ¯åˆ°æ‰€æœ‰Webå®¢æˆ·ç«¯"""
        if not self.websocket_connections:
            return

        message_json = json.dumps(message)
        disconnected_clients = []

        for client_addr, websocket in self.websocket_connections.items():
            try:
                await websocket.send_text(message_json)
                logger.debug(f"ğŸ“¤ å·²å‘é€æ¶ˆæ¯ç»™å®¢æˆ·ç«¯ {client_addr}: {message['type']}")
            except Exception as e:
                logger.warning(f"âš ï¸ å‘é€æ¶ˆæ¯ç»™å®¢æˆ·ç«¯ {client_addr} å¤±è´¥: {e}")
                disconnected_clients.append(client_addr)

        # æ¸…ç†æ–­å¼€çš„è¿æ¥
        for client_addr in disconnected_clients:
            if client_addr in self.websocket_connections:
                del self.websocket_connections[client_addr]

    async def broadcast_audio_to_web_clients(self, audio_data: bytes):
        """å¹¿æ’­éŸ³é¢‘æ•°æ®åˆ°æ‰€æœ‰Webå®¢æˆ·ç«¯"""
        if not self.websocket_connections:
            return

        # æ„é€ éŸ³é¢‘æ¶ˆæ¯
        audio_message = {
            'type': 'audio_data',
            'size': len(audio_data),
            'timestamp': time.time()
        }

        disconnected_clients = []

        for client_addr, websocket in self.websocket_connections.items():
            try:
                # å…ˆå‘é€éŸ³é¢‘å…ƒæ•°æ®
                await websocket.send_text(json.dumps(audio_message))
                # å†å‘é€éŸ³é¢‘æ•°æ®
                await websocket.send_bytes(audio_data)
                logger.debug(f"ğŸ”Š å·²å‘é€éŸ³é¢‘æ•°æ®ç»™å®¢æˆ·ç«¯ {client_addr}: {len(audio_data)} å­—èŠ‚")
            except Exception as e:
                logger.warning(f"âš ï¸ å‘é€éŸ³é¢‘æ•°æ®ç»™å®¢æˆ·ç«¯ {client_addr} å¤±è´¥: {e}")
                disconnected_clients.append(client_addr)

        # æ¸…ç†æ–­å¼€çš„è¿æ¥
        for client_addr in disconnected_clients:
            if client_addr in self.websocket_connections:
                del self.websocket_connections[client_addr]

    async def inject_to_zoev3(self, opus_data: bytes) -> bool:
        """å°†OPUSæ•°æ®ç›´æ¥æ³¨å…¥åˆ°Zoev3çš„éŸ³é¢‘æ¥å£"""
        try:
            logger.info(f"ğŸŒ‰ [BRIDGE-STEP-1] å¼€å§‹æ³¨å…¥OPUSæ•°æ®åˆ°Zoev3: {len(opus_data)} å­—èŠ‚")

            # æ–¹æ¡ˆ1: HTTP POSTåˆ°Zoev3çš„éŸ³é¢‘APIç«¯ç‚¹
            try:
                logger.info("ğŸŒ‰ [BRIDGE-STEP-2] å°è¯•HTTP POSTæ–¹å¼æ³¨å…¥")
                async with aiohttp.ClientSession() as session:
                    async with session.post(
                        'http://localhost:8890/audio',
                        data=opus_data,
                        headers={'Content-Type': 'application/octet-stream'},
                        timeout=aiohttp.ClientTimeout(total=2.0)
                    ) as response:
                        if response.status == 200:
                            logger.info(f"âœ… [BRIDGE-SUCCESS] HTTPéŸ³é¢‘æ•°æ®å·²å‘é€åˆ°Zoev3: {len(opus_data)} å­—èŠ‚")
                            return True
                        else:
                            logger.warning(f"âš ï¸ [BRIDGE-WARNING] HTTPè¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç : {response.status}")
            except Exception as http_error:
                logger.warning(f"âš ï¸ [BRIDGE-WARNING] HTTPæ³¨å…¥å¤±è´¥: {http_error}ï¼Œå°è¯•ç›´æ¥è°ƒç”¨")

            # æ–¹æ¡ˆ2: ç›´æ¥è°ƒç”¨Zoev3çš„_on_encoded_audioæ–¹æ³•ï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰
            app_instance = self.get_zoev3_application_instance()
            if app_instance and hasattr(app_instance, '_on_encoded_audio'):
                # ç›´æ¥è°ƒç”¨éŸ³é¢‘å¤„ç†æ¥å£
                app_instance._on_encoded_audio(opus_data)
                logger.debug(f"ğŸ“¤ éŸ³é¢‘æ•°æ®å·²ç›´æ¥æ³¨å…¥Zoev3: {len(opus_data)} å­—èŠ‚")
                return True

            logger.error("âŒ æ‰€æœ‰éŸ³é¢‘æ³¨å…¥æ–¹æ¡ˆéƒ½å¤±è´¥")
            return False

        except Exception as e:
            logger.error(f"âŒ éŸ³é¢‘æ³¨å…¥å¤±è´¥: {e}")
            return False

    async def test_audio_injection(self) -> bool:
        """æµ‹è¯•éŸ³é¢‘æ³¨å…¥åŠŸèƒ½"""
        try:
            # åˆ›å»ºæµ‹è¯•éŸ³é¢‘æ•°æ® (60ms @ 16kHz)
            test_audio = np.random.randint(-1000, 1000, 960, dtype=np.int16)
            test_bytes = test_audio.tobytes()

            if self.opus_encoder:
                opus_data = self.opus_encoder.encode(test_bytes, 960)
                return await self.inject_to_zoev3(opus_data)

            return False

        except Exception as e:
            logger.error(f"âŒ éŸ³é¢‘æ³¨å…¥æµ‹è¯•å¤±è´¥: {e}")
            return False

# æ³¨æ„ï¼šä¸éœ€è¦æ¡¥æ¥å™¨è‡ªå·±çš„ç›‘å¬å™¨ï¼ŒZoev3ä¼šå¤„ç†æ–‡ä»¶ç³»ç»Ÿæ³¨å…¥

async def main():
    """ä¸»å‡½æ•°"""
    bridge = Zoev3AudioBridge()

    # åˆå§‹åŒ–OPUSç¼–ç å™¨
    if await bridge.initialize_opus_encoder():
        logger.info("âœ… éŸ³é¢‘æ¡¥æ¥å™¨åˆå§‹åŒ–æˆåŠŸ")
    else:
        logger.error("âŒ éŸ³é¢‘æ¡¥æ¥å™¨åˆå§‹åŒ–å¤±è´¥")
        return

    # Zoev3ä¼šè‡ªå·±å¤„ç†æ–‡ä»¶ç³»ç»Ÿæ³¨å…¥ï¼Œä¸éœ€è¦é¢å¤–ç›‘å¬å™¨

    # æ£€æŸ¥Zoev3çŠ¶æ€
    zoev3_status = bridge.check_zoev3_connection()
    logger.info(f"ğŸ” Zoev3çŠ¶æ€æ£€æŸ¥: {zoev3_status}")

    # è®¾ç½®Zoev3ç›‘å¬
    if bridge.setup_zoev3_monitoring():
        logger.info("âœ… Zoev3ç³»ç»Ÿç›‘å¬è®¾ç½®æˆåŠŸ")
    else:
        logger.warning("âš ï¸ Zoev3ç³»ç»Ÿç›‘å¬è®¾ç½®å¤±è´¥ï¼Œéƒ¨åˆ†åŠŸèƒ½å¯èƒ½ä¸å¯ç”¨")

    logger.info("ğŸš€ å¯åŠ¨Zoev4 â†’ Zoev3 éŸ³é¢‘æ¡¥æ¥æœåŠ¡å™¨...")
    logger.info("ğŸ“– æµ‹è¯•é¡µé¢: http://localhost:8004/")
    logger.info("ğŸ“Š æ¡¥æ¥çŠ¶æ€: http://localhost:8004/status")
    logger.info("ğŸ§ª æ³¨å…¥æµ‹è¯•: http://localhost:8004/inject-test")

    config = uvicorn.Config(
        app=bridge.app,
        host="localhost",
        port=8004,  # ä½¿ç”¨æ–°ç«¯å£é¿å…å†²çª
        log_level="debug"
    )

    server_instance = uvicorn.Server(config)
    await server_instance.serve()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("ğŸ‘‹ éŸ³é¢‘æ¡¥æ¥æœåŠ¡å™¨å·²åœæ­¢")
    except Exception as e:
        logger.error(f"âŒ æœåŠ¡å™¨å¯åŠ¨å¤±è´¥: {e}")
        sys.exit(1)