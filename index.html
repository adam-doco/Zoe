<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live2D Model Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0b1c21;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            position: relative;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            border: 2px solid #12b886; /* ä¸´æ—¶è¾¹æ¡†ï¼Œç”¨äºè°ƒè¯•å®šä½ */
        }

        #controls {
            position: fixed;
            top: 50px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 300px;
        }

        .control-group {
            background: rgba(11, 28, 33, 0.9);
            border: 1px solid #12b886;
            border-radius: 8px;
            padding: 10px;
        }

        .control-group h3 {
            margin: 0 0 10px 0;
            color: #12b886;
            font-size: 14px;
            font-weight: bold;
        }

        .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .control-btn {
            background-color: #12b886;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }

        .control-btn:hover {
            background-color: #0ca26e;
        }

        .control-btn:active {
            background-color: #099268;
        }

        #error-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #dc3545;
            color: white;
            padding: 12px 20px;
            text-align: center;
            z-index: 2000;
            display: none;
            font-size: 14px;
        }

        #loading-status {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(11, 28, 33, 0.9);
            color: #12b886;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #12b886;
            text-align: center;
            z-index: 1500;
            font-size: 16px;
        }

        #voice-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 15px;
            align-items: center;
            background: rgba(11, 28, 33, 0.9);
            border: 1px solid #12b886;
            border-radius: 12px;
            padding: 15px 25px;
        }

        #voice-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid #12b886;
            background: transparent;
            color: #12b886;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #voice-btn:hover {
            background: rgba(18, 184, 134, 0.1);
            transform: scale(1.05);
        }

        #voice-btn.recording {
            background: #dc3545;
            border-color: #dc3545;
            color: white;
            animation: pulse 1.5s infinite;
        }

        #voice-btn.connecting {
            background: #ffc107;
            border-color: #ffc107;
            color: #000;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        #voice-status {
            color: #12b886;
            font-size: 14px;
            min-width: 120px;
        }

        #interrupt-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }

        #interrupt-btn:hover {
            background: #c82333;
        }

        #interrupt-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .loading-spinner {
            border: 2px solid #12b886;
            border-top: 2px solid transparent;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="error-bar"></div>
    
    <div id="loading-status">
        <div class="loading-spinner"></div>
        æ­£åœ¨åˆå§‹åŒ– Live2D åº”ç”¨...
    </div>
    
    <canvas id="canvas"></canvas>
    
    <div id="controls">
        <div class="control-group">
            <h3>Motions</h3>
            <div id="motion-buttons" class="button-container"></div>
        </div>
        
        <div class="control-group">
            <h3>Expressions</h3>
            <div id="expression-buttons" class="button-container"></div>
        </div>
    </div>

    <div id="voice-controls">
        <button id="voice-btn" title="é•¿æŒ‰è¯´è¯">ğŸ¤</button>
        <div id="voice-status">ç‚¹å‡»è¿æ¥</div>
        <button id="interrupt-btn" disabled>æ‰“æ–­</button>
    </div>

    <!-- è„šæœ¬å°†åŠ¨æ€åŠ è½½ä»¥ç¡®ä¿æ­£ç¡®é¡ºåº -->

    <script>
        // åŠ¨æ€è„šæœ¬åŠ è½½å™¨
        class ScriptLoader {
            static loadScript(src, id = null, timeout = 30000) {
                return new Promise((resolve, reject) => {
                    console.log(`ğŸ“¥ å¼€å§‹åŠ è½½è„šæœ¬: ${src}`);
                    
                    const script = document.createElement('script');
                    script.src = src;
                    script.async = true;
                    if (id) script.id = id;
                    
                    let timeoutId = setTimeout(() => {
                        reject(new Error(`è„šæœ¬åŠ è½½è¶…æ—¶: ${src}`));
                    }, timeout);
                    
                    script.onload = () => {
                        clearTimeout(timeoutId);
                        console.log(`âœ“ è„šæœ¬åŠ è½½æˆåŠŸ: ${src}`);
                        resolve();
                    };
                    
                    script.onerror = (error) => {
                        clearTimeout(timeoutId);
                        console.error(`âœ— è„šæœ¬åŠ è½½å¤±è´¥: ${src}`, error);
                        reject(new Error(`è„šæœ¬åŠ è½½å¤±è´¥: ${src}`));
                    };
                    
                    document.head.appendChild(script);
                });
            }

            static async loadScriptsSequentially() {
                try {
                    // æ­¥éª¤ 1: åŠ è½½ Live2D Cubism Core
                    console.log('ğŸš€ æ­¥éª¤ 1: åŠ è½½ Live2D Cubism Core...');
                    await this.loadScript('libs/live2dcubismcore.min.js', 'cubism-core');
                    
                    // éªŒè¯ Cubism Core åŠ è½½
                    if (typeof Live2DCubismCore === 'undefined') {
                        throw new Error('Live2DCubismCore æœªæ­£ç¡®åŠ è½½');
                    }
                    console.log('âœ“ Live2DCubismCore åŠ è½½æˆåŠŸ');
                    
                    // æ­¥éª¤ 2: åŠ è½½ PIXI.js
                    console.log('ğŸš€ æ­¥éª¤ 2: åŠ è½½ PIXI.js...');
                    await this.loadScript('https://unpkg.com/pixi.js@7/dist/pixi.min.js', 'pixi');
                    
                    // éªŒè¯ PIXI åŠ è½½å¹¶è®¾ç½®å…¨å±€å˜é‡
                    if (typeof PIXI === 'undefined') {
                        throw new Error('PIXI æœªæ­£ç¡®åŠ è½½');
                    }
                    window.PIXI = PIXI; // ç«‹å³è®¾ç½®å…¨å±€å˜é‡
                    console.log('âœ“ PIXI åŠ è½½æˆåŠŸå¹¶è®¾ç½®å…¨å±€å˜é‡');
                    
                    // æ­¥éª¤ 3: åŠ è½½ pixi-live2d-display (å¤šå±‚é™çº§ç­–ç•¥)
                    console.log('ğŸš€ æ­¥éª¤ 3: åŠ è½½ pixi-live2d-display...');
                    await this.loadLive2DDisplay();
                    
                    console.log('ğŸ‰ æ‰€æœ‰è„šæœ¬åŠ è½½å®Œæˆï¼');
                    return true;
                    
                } catch (error) {
                    console.error('âŒ è„šæœ¬åŠ è½½å¤±è´¥:', error);
                    throw error;
                }
            }

            static async loadLive2DDisplay() {
                const strategies = [
                    {
                        name: '0.4.0 Cubism4ä¸“ç”¨ç‰ˆæœ¬',
                        url: 'https://unpkg.com/pixi-live2d-display@0.4.0/dist/cubism4.min.js',
                        id: 'live2d-cubism4'
                    },
                    {
                        name: '0.4.0 å®Œæ•´ç‰ˆæœ¬ï¼ˆé™çº§ï¼‰',
                        url: 'https://unpkg.com/pixi-live2d-display@0.4.0/dist/index.min.js',
                        id: 'live2d-index'
                    },
                    {
                        name: '0.5.0-beta Cubism4ç‰ˆæœ¬',
                        url: 'https://unpkg.com/pixi-live2d-display@0.5.0-beta/dist/cubism4.min.js',
                        id: 'live2d-beta-cubism4'
                    },
                    {
                        name: '0.5.0-beta å®Œæ•´ç‰ˆæœ¬',
                        url: 'https://unpkg.com/pixi-live2d-display@0.5.0-beta/dist/index.min.js',
                        id: 'live2d-beta-index'
                    }
                ];

                for (let i = 0; i < strategies.length; i++) {
                    const strategy = strategies[i];
                    console.log(`ğŸ“¦ å°è¯•ç­–ç•¥ ${i + 1}: ${strategy.name}`);
                    
                    try {
                        await this.loadScript(strategy.url, strategy.id);
                        
                        // ç­‰å¾…æ’ä»¶åˆå§‹åŒ–
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        // éªŒè¯åŠ è½½æˆåŠŸ
                        if (window.PIXI.live2d && window.PIXI.live2d.Live2DModel) {
                            console.log(`âœ“ ${strategy.name} åŠ è½½æˆåŠŸï¼`);
                            return;
                        } else {
                            throw new Error('æ’ä»¶æœªæ­£ç¡®åˆå§‹åŒ–');
                        }
                        
                    } catch (error) {
                        console.warn(`âŒ ç­–ç•¥ ${i + 1} å¤±è´¥: ${error.message}`);
                        
                        // æ¸…ç†å¤±è´¥çš„è„šæœ¬
                        const script = document.getElementById(strategy.id);
                        if (script) script.remove();
                        
                        // å¦‚æœæ˜¯æœ€åä¸€ä¸ªç­–ç•¥ï¼ŒæŠ›å‡ºé”™è¯¯
                        if (i === strategies.length - 1) {
                            throw new Error('æ‰€æœ‰åŠ è½½ç­–ç•¥éƒ½å¤±è´¥äº†');
                        }
                        
                        console.log(`ğŸ”„ å°è¯•ä¸‹ä¸€ä¸ªç­–ç•¥...`);
                    }
                }
            }

            static async loadWithFallback() {
                try {
                    // é¦–æ¬¡å°è¯• unpkg CDN
                    console.log('ğŸŒ å°è¯•ä¸»CDN (unpkg)...');
                    await this.loadScriptsSequentially();
                } catch (error) {
                    console.warn('ğŸ”„ ä¸»CDNå¤±è´¥ï¼Œå°è¯•å¤‡ç”¨CDN (jsDelivr)...');
                    
                    try {
                        // æ¸…ç†å·²åŠ è½½çš„è„šæœ¬
                        const scriptIds = ['cubism-core', 'pixi', 'live2d-cubism4', 'live2d-index', 
                                         'live2d-beta-cubism4', 'live2d-beta-index'];
                        scriptIds.forEach(id => {
                            const script = document.getElementById(id);
                            if (script) script.remove();
                        });
                        
                        // é‡æ–°åŠ è½½ï¼Œä½¿ç”¨ jsDelivr CDN
                        console.log('ğŸš€ æ­¥éª¤ 1 (jsDelivr): åŠ è½½ Live2D Cubism Core...');
                        await this.loadScript('libs/live2dcubismcore.min.js', 'cubism-core-fallback');
                        if (typeof Live2DCubismCore === 'undefined') {
                            throw new Error('Live2DCubismCore æœªæ­£ç¡®åŠ è½½');
                        }
                        
                        console.log('ğŸš€ æ­¥éª¤ 2 (jsDelivr): åŠ è½½ PIXI.js...');
                        await this.loadScript('https://cdn.jsdelivr.net/npm/pixi.js@7/dist/pixi.min.js', 'pixi-fallback');
                        window.PIXI = PIXI;
                        
                        console.log('ğŸš€ æ­¥éª¤ 3 (jsDelivr): åŠ è½½ pixi-live2d-display...');
                        await this.loadLive2DDisplayFallback();
                        
                        console.log('âœ“ å¤‡ç”¨CDNåŠ è½½æˆåŠŸ');
                        
                    } catch (fallbackError) {
                        console.error('âŒ å¤‡ç”¨CDNä¹Ÿå¤±è´¥:', fallbackError);
                        throw new Error(`è„šæœ¬åŠ è½½å½»åº•å¤±è´¥: ä¸»CDNå¤±è´¥ - ${error.message}; å¤‡ç”¨CDNå¤±è´¥ - ${fallbackError.message}`);
                    }
                }
            }

            static async loadLive2DDisplayFallback() {
                const fallbackStrategies = [
                    {
                        name: 'jsDelivr 0.4.0 Cubism4ä¸“ç”¨',
                        url: 'https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.4.0/dist/cubism4.min.js',
                        id: 'live2d-jsdelivr-cubism4'
                    },
                    {
                        name: 'jsDelivr 0.4.0 å®Œæ•´ç‰ˆæœ¬',
                        url: 'https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.4.0/dist/index.min.js',
                        id: 'live2d-jsdelivr-index'
                    }
                ];

                for (let i = 0; i < fallbackStrategies.length; i++) {
                    const strategy = fallbackStrategies[i];
                    console.log(`ğŸ“¦ å¤‡ç”¨ç­–ç•¥ ${i + 1}: ${strategy.name}`);
                    
                    try {
                        await this.loadScript(strategy.url, strategy.id);
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        if (window.PIXI.live2d && window.PIXI.live2d.Live2DModel) {
                            console.log(`âœ“ ${strategy.name} åŠ è½½æˆåŠŸï¼`);
                            return;
                        } else {
                            throw new Error('æ’ä»¶æœªæ­£ç¡®åˆå§‹åŒ–');
                        }
                        
                    } catch (error) {
                        console.warn(`âŒ å¤‡ç”¨ç­–ç•¥ ${i + 1} å¤±è´¥: ${error.message}`);
                        const script = document.getElementById(strategy.id);
                        if (script) script.remove();
                        
                        if (i === fallbackStrategies.length - 1) {
                            throw new Error('æ‰€æœ‰å¤‡ç”¨ç­–ç•¥éƒ½å¤±è´¥äº†');
                        }
                    }
                }
            }
        }

        // å°æ™ºç½‘å…³å®¢æˆ·ç«¯
        class XiaozhiClient {
            constructor() {
                this.sessionId = null;
                this.ws = null;
                this.isConnected = false;
                this.isRecording = false;
                this.mediaRecorder = null;
                this.audioStream = null;
                
                this.gatewayUrl = 'http://localhost:3000';
                this.wsUrl = null;
                
                // éŸ³é¢‘ç›¸å…³
                this.audioContext = null;
                this.processor = null;
                
                // UIå…ƒç´ 
                this.voiceBtn = null;
                this.voiceStatus = null;
                this.interruptBtn = null;
                
                // å›è°ƒ
                this.onSttResult = null;
                this.onLlmResponse = null;
                this.onTtsUrl = null;
                this.onError = null;
            }

            async init() {
                try {
                    // è·å–UIå…ƒç´ 
                    this.voiceBtn = document.getElementById('voice-btn');
                    this.voiceStatus = document.getElementById('voice-status');
                    this.interruptBtn = document.getElementById('interrupt-btn');

                    // ç»‘å®šäº‹ä»¶
                    this.voiceBtn.addEventListener('mousedown', () => this.startVoiceInput());
                    this.voiceBtn.addEventListener('mouseup', () => this.stopVoiceInput());
                    this.voiceBtn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.startVoiceInput();
                    });
                    this.voiceBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.stopVoiceInput();
                    });
                    this.voiceBtn.addEventListener('click', () => this.connectToGateway());
                    
                    this.interruptBtn.addEventListener('click', () => this.interrupt());

                    console.log('âœ“ XiaozhiClient åˆå§‹åŒ–å®Œæˆ');
                } catch (error) {
                    console.error('XiaozhiClient åˆå§‹åŒ–å¤±è´¥:', error);
                    this.updateStatus('åˆå§‹åŒ–å¤±è´¥');
                }
            }

            async connectToGateway() {
                if (this.isConnected) return;

                try {
                    this.updateStatus('æ­£åœ¨è¿æ¥...');
                    this.voiceBtn.className = 'connecting';
                    
                    // åˆ›å»ºä¼šè¯
                    console.log('æ­£åœ¨è¯·æ±‚:', `${this.gatewayUrl}/session`);
                    const response = await fetch(`${this.gatewayUrl}/session`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ userId: 'live2d-user' })
                    });
                    console.log('æ”¶åˆ°å“åº”:', response);

                    if (!response.ok) {
                        throw new Error(`ä¼šè¯åˆ›å»ºå¤±è´¥: ${response.status}`);
                    }

                    const { sessionId, wsUrl } = await response.json();
                    this.sessionId = sessionId;
                    this.wsUrl = wsUrl.replace('http:', 'ws:');
                    
                    console.log('âœ“ ä¼šè¯åˆ›å»ºæˆåŠŸ:', { sessionId, wsUrl: this.wsUrl });

                    // è¿æ¥WebSocket
                    await this.connectWebSocket();
                    
                } catch (error) {
                    console.error('è¿æ¥ç½‘å…³å¤±è´¥:', error);
                    console.error('é”™è¯¯è¯¦æƒ…:', {
                        message: error.message,
                        stack: error.stack,
                        type: error.constructor.name,
                        gatewayUrl: this.gatewayUrl
                    });
                    this.updateStatus(`è¿æ¥å¤±è´¥: ${error.message}`);
                    this.voiceBtn.className = '';
                    if (this.onError) this.onError(error);
                }
            }

            async connectWebSocket() {
                return new Promise((resolve, reject) => {
                    try {
                        this.ws = new WebSocket(this.wsUrl);
                        
                        this.ws.onopen = () => {
                            console.log('âœ“ WebSocketè¿æ¥æˆåŠŸ');
                            this.isConnected = true;
                            this.updateStatus('é•¿æŒ‰è¯´è¯');
                            this.voiceBtn.className = '';
                            this.interruptBtn.disabled = false;
                            resolve();
                        };

                        this.ws.onmessage = (event) => {
                            try {
                                const message = JSON.parse(event.data);
                                this.handleMessage(message);
                            } catch (error) {
                                console.error('è§£ææ¶ˆæ¯å¤±è´¥:', error);
                            }
                        };

                        this.ws.onclose = () => {
                            console.log('WebSocketè¿æ¥å…³é—­');
                            this.isConnected = false;
                            this.updateStatus('è¿æ¥æ–­å¼€');
                            this.voiceBtn.className = '';
                            this.interruptBtn.disabled = true;
                        };

                        this.ws.onerror = (error) => {
                            console.error('WebSocketé”™è¯¯:', error);
                            reject(error);
                        };

                        // è¿æ¥è¶…æ—¶
                        setTimeout(() => {
                            if (!this.isConnected) {
                                reject(new Error('WebSocketè¿æ¥è¶…æ—¶'));
                            }
                        }, 5000);

                    } catch (error) {
                        reject(error);
                    }
                });
            }

            handleMessage(message) {
                console.log('æ”¶åˆ°æ¶ˆæ¯:', message);
                
                switch (message.type) {
                    case 'stt':
                        console.log('è¯­éŸ³è¯†åˆ«ç»“æœ:', message.data.text);
                        if (this.onSttResult) this.onSttResult(message.data.text);
                        break;
                        
                    case 'llm':
                        console.log('AIå›å¤:', message.data.text);
                        if (this.onLlmResponse) this.onLlmResponse(message.data.text);
                        break;
                        
                    case 'tts_start':
                        console.log('TTSå¼€å§‹');
                        this.updateStatus('AIæ­£åœ¨å›å¤...');
                        break;
                        
                    case 'tts_url':
                        console.log('TTSéŸ³é¢‘URL:', message.data.url);
                        this.updateStatus('æ’­æ”¾å›å¤ä¸­...');
                        if (this.onTtsUrl) this.onTtsUrl(message.data.url);
                        break;
                        
                    case 'tts_end':
                        console.log('TTSç»“æŸ');
                        this.updateStatus('é•¿æŒ‰è¯´è¯');
                        break;
                        
                    case 'error':
                        console.error('æœåŠ¡å™¨é”™è¯¯:', message.data);
                        this.updateStatus('æœåŠ¡å™¨é”™è¯¯');
                        if (this.onError) this.onError(new Error(message.data.message || 'æœåŠ¡å™¨é”™è¯¯'));
                        break;
                        
                    default:
                        console.log('æœªçŸ¥æ¶ˆæ¯ç±»å‹:', message.type);
                }
            }

            async startVoiceInput() {
                if (!this.isConnected) {
                    await this.connectToGateway();
                    return;
                }
                
                if (this.isRecording) return;

                try {
                    console.log('å¼€å§‹å½•éŸ³...');
                    this.isRecording = true;
                    this.voiceBtn.className = 'recording';
                    this.updateStatus('æ­£åœ¨å½•éŸ³...');

                    // è·å–éŸ³é¢‘æµ
                    this.audioStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        }
                    });

                    // åˆ›å»ºAudioContextå’Œå¤„ç†å™¨
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({ 
                        sampleRate: 16000 
                    });
                    
                    const source = this.audioContext.createMediaStreamSource(this.audioStream);
                    
                    // ä½¿ç”¨ScriptProcessorNodeå¤„ç†éŸ³é¢‘
                    this.processor = this.audioContext.createScriptProcessor(4096, 1, 1);
                    
                    this.processor.onaudioprocess = (event) => {
                        if (!this.isRecording) return;
                        
                        const inputBuffer = event.inputBuffer;
                        const inputData = inputBuffer.getChannelData(0);
                        
                        // è½¬æ¢ä¸º16ä½PCM
                        const pcmData = this.float32To16BitPCM(inputData);
                        
                        // å‘é€åˆ°ç½‘å…³
                        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                            this.ws.send(pcmData);
                        }
                    };

                    source.connect(this.processor);
                    this.processor.connect(this.audioContext.destination);

                } catch (error) {
                    console.error('å¼€å§‹å½•éŸ³å¤±è´¥:', error);
                    this.stopVoiceInput();
                    this.updateStatus('å½•éŸ³å¤±è´¥');
                    if (this.onError) this.onError(error);
                }
            }

            stopVoiceInput() {
                if (!this.isRecording) return;

                try {
                    console.log('åœæ­¢å½•éŸ³...');
                    this.isRecording = false;
                    this.voiceBtn.className = '';
                    this.updateStatus('å¤„ç†ä¸­...');

                    // æ¸…ç†éŸ³é¢‘èµ„æº
                    if (this.processor) {
                        this.processor.disconnect();
                        this.processor = null;
                    }

                    if (this.audioContext) {
                        this.audioContext.close();
                        this.audioContext = null;
                    }

                    if (this.audioStream) {
                        this.audioStream.getTracks().forEach(track => track.stop());
                        this.audioStream = null;
                    }

                } catch (error) {
                    console.error('åœæ­¢å½•éŸ³å¤±è´¥:', error);
                }
            }

            float32To16BitPCM(float32Array) {
                const buffer = new ArrayBuffer(float32Array.length * 2);
                const view = new DataView(buffer);
                let offset = 0;
                
                for (let i = 0; i < float32Array.length; i++, offset += 2) {
                    let sample = Math.max(-1, Math.min(1, float32Array[i]));
                    sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(offset, sample, true);
                }
                
                return buffer;
            }

            interrupt() {
                if (!this.isConnected || !this.ws) return;

                try {
                    console.log('å‘é€æ‰“æ–­ä¿¡å·...');
                    this.ws.send(JSON.stringify({ type: 'interrupt' }));
                    this.updateStatus('å·²æ‰“æ–­');
                } catch (error) {
                    console.error('æ‰“æ–­å¤±è´¥:', error);
                    if (this.onError) this.onError(error);
                }
            }

            updateStatus(status) {
                if (this.voiceStatus) {
                    this.voiceStatus.textContent = status;
                }
            }

            disconnect() {
                this.stopVoiceInput();
                
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                
                this.isConnected = false;
                this.sessionId = null;
                this.wsUrl = null;
                this.updateStatus('å·²æ–­å¼€');
                
                if (this.interruptBtn) {
                    this.interruptBtn.disabled = true;
                }
            }
        }

        class Live2DApp {
            constructor() {
                this.app = null;
                this.model = null;
                this.modelSettings = null;
                this.errorBar = document.getElementById('error-bar');
                this.loadingStatus = document.getElementById('loading-status');
                
                // å°æ™ºå®¢æˆ·ç«¯
                this.xiaozhiClient = new XiaozhiClient();
                this.currentTTSAudio = null;
                
                this.init();
            }

            showError(message) {
                console.error(message);
                this.errorBar.textContent = message;
                this.errorBar.style.display = 'block';
                this.hideLoading();
            }

            hideError() {
                this.errorBar.style.display = 'none';
            }

            updateLoadingStatus(message) {
                console.log(`ğŸ“ ${message}`);
                if (this.loadingStatus) {
                    this.loadingStatus.innerHTML = `<div class="loading-spinner"></div>${message}`;
                }
            }

            hideLoading() {
                if (this.loadingStatus) {
                    this.loadingStatus.style.display = 'none';
                }
            }

            async checkModelFile() {
                const modelPath = 'Mould/Z.model3.json';
                try {
                    const response = await fetch(modelPath, { method: 'HEAD' });
                    console.log(`HEAD ${modelPath}: ${response.status}`);
                    
                    if (!response.ok) {
                        this.showError('è¯·é€šè¿‡ HTTP æ‰“å¼€è€Œä¸æ˜¯ file://ï¼Œå¹¶æ£€æŸ¥è·¯å¾„å¤§å°å†™');
                        return false;
                    }
                    return true;
                } catch (error) {
                    console.log(`HEAD ${modelPath}: è¯·æ±‚å¤±è´¥`);
                    this.showError('è¯·é€šè¿‡ HTTP æ‰“å¼€è€Œä¸æ˜¯ file://ï¼Œå¹¶æ£€æŸ¥è·¯å¾„å¤§å°å†™');
                    return false;
                }
            }

            async init() {
                try {
                    this.updateLoadingStatus('æ­£åœ¨åˆå§‹åŒ– Live2D åº”ç”¨...');
                    
                    // ä½¿ç”¨æ–°çš„è„šæœ¬åŠ è½½å™¨
                    this.updateLoadingStatus('æ­£åœ¨æŒ‰é¡ºåºåŠ è½½è„šæœ¬ä¾èµ–...');
                    await ScriptLoader.loadWithFallback();
                    
                    // æ£€æŸ¥æ¨¡å‹æ–‡ä»¶æ˜¯å¦å¯è®¿é—®
                    this.updateLoadingStatus('æ­£åœ¨æ£€æŸ¥æ¨¡å‹æ–‡ä»¶...');
                    const modelAccessible = await this.checkModelFile();
                    if (!modelAccessible) {
                        return;
                    }

                    // åˆ›å»º PIXI åº”ç”¨ - ä½¿ç”¨ç®€åŒ–é…ç½®
                    this.updateLoadingStatus('æ­£åœ¨åˆ›å»º PIXI åº”ç”¨...');
                    this.app = new window.PIXI.Application({
                        view: document.getElementById('canvas'),
                        width: window.innerWidth,
                        height: window.innerHeight,
                        backgroundColor: 0x0b1c21 // ç›´æ¥è®¾ç½®èƒŒæ™¯è‰²
                    });

                    console.log('âœ“ PIXI åº”ç”¨åˆ›å»ºæˆåŠŸ');

                    // çª—å£å¤§å°è°ƒæ•´
                    window.addEventListener('resize', () => this.resize());

                    // åŠ è½½æ¨¡å‹
                    this.updateLoadingStatus('æ­£åœ¨åŠ è½½ Live2D æ¨¡å‹...');
                    await this.loadModel();
                    
                } catch (error) {
                    this.showError(`åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
                    console.error('åˆå§‹åŒ–è¯¦ç»†é”™è¯¯:', error);
                }
            }

            async loadModel() {
                try {
                    const modelPath = 'Mould/Z.model3.json';
                    
                    console.log('å¼€å§‹åŠ è½½æ¨¡å‹:', modelPath);
                    
                    // ä½¿ç”¨å®˜æ–¹æ¨èçš„ Live2DModel.from() æ–¹æ³•
                    this.updateLoadingStatus('æ­£åœ¨è§£ææ¨¡å‹æ–‡ä»¶...');
                    this.model = await window.PIXI.live2d.Live2DModel.from(modelPath);
                    
                    if (!this.model) {
                        throw new Error('æ¨¡å‹å¯¹è±¡ä¸ºç©º');
                    }

                    console.log('âœ“ æ¨¡å‹åŠ è½½æˆåŠŸï¼Œå¼€å§‹è®¾ç½®...');
                    this.updateLoadingStatus('æ­£åœ¨è®¾ç½®æ¨¡å‹å‚æ•°...');

                    // è·å–æ¨¡å‹è®¾ç½® - ä½¿ç”¨æ­£ç¡®çš„è®¿é—®æ–¹å¼
                    this.modelSettings = this.model.internalModel.settings;
                    
                    // æ‰“å°è°ƒè¯•ä¿¡æ¯
                    console.log('æ¨¡å‹è®¾ç½®ä¿¡æ¯:');
                    if (this.modelSettings.motions) {
                        console.table(this.modelSettings.motions);
                    }
                    if (this.modelSettings.expressions) {
                        console.table(this.modelSettings.expressions);
                    }

                    // æ·»åŠ æ¨¡å‹åˆ°èˆå°
                    this.updateLoadingStatus('æ­£åœ¨å°†æ¨¡å‹æ·»åŠ åˆ°èˆå°...');
                    this.app.stage.addChild(this.model);

                    // è®¾ç½®æ¨¡å‹ä½ç½®å’Œç¼©æ”¾
                    this.updateLoadingStatus('æ­£åœ¨è°ƒæ•´æ¨¡å‹ä½ç½®...');
                    this.positionModel();

                    // åˆ›å»ºæ§åˆ¶æŒ‰é’®
                    this.updateLoadingStatus('æ­£åœ¨åˆ›å»ºæ§åˆ¶æŒ‰é’®...');
                    this.createControls();

                    // åˆå§‹åŒ–å°æ™ºå®¢æˆ·ç«¯
                    this.updateLoadingStatus('æ­£åœ¨åˆå§‹åŒ–è¯­éŸ³åŠŸèƒ½...');
                    await this.setupXiaozhiClient();

                    this.hideError();
                    this.hideLoading();
                    console.log('âœ“ Live2D æ¨¡å‹å’Œè¯­éŸ³åŠŸèƒ½å®Œå…¨è®¾ç½®å®Œæˆ');

                } catch (error) {
                    this.showError(`æ¨¡å‹åŠ è½½å¤±è´¥: ${error.message}`);
                    console.error('æ¨¡å‹åŠ è½½è¯¦ç»†é”™è¯¯:', error);
                    console.error('é”™è¯¯å †æ ˆ:', error.stack);
                }
            }

            positionModel() {
                if (!this.model) return;

                const canvas = this.app.view;
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;

                console.log(`ğŸ” ç”»å¸ƒå°ºå¯¸: ${canvasWidth} x ${canvasHeight}`);

                // å…ˆé‡ç½®æ¨¡å‹ä½ç½®å’Œç¼©æ”¾
                this.model.x = 0;
                this.model.y = 0;
                this.model.scale.set(1);

                // è·å–æ¨¡å‹çš„åŸå§‹è¾¹ç•Œ
                const originalBounds = this.model.getBounds();
                console.log(`ğŸ” åŸå§‹è¾¹ç•Œ:`, {
                    x: originalBounds.x,
                    y: originalBounds.y, 
                    width: originalBounds.width,
                    height: originalBounds.height
                });

                // è®¾ç½®é”šç‚¹åˆ°æ¨¡å‹ä¸­å¿ƒ
                this.model.anchor.set(0.5, 0.5);
                
                // é‡æ–°è·å–è¾¹ç•Œï¼ˆè®¾ç½®é”šç‚¹åï¼‰
                const bounds = this.model.getBounds();
                const modelWidth = bounds.width;
                const modelHeight = bounds.height;
                
                console.log(`ğŸ” é”šç‚¹è®¾ç½®åè¾¹ç•Œ: ${modelWidth} x ${modelHeight}`);

                // è®¡ç®—é€‚åˆçš„ç¼©æ”¾æ¯”ä¾‹
                const scaleX = (canvasWidth * 0.8) / modelWidth; // 80% ç”»å¸ƒå®½åº¦
                const scaleY = (canvasHeight * 0.8) / modelHeight; // 80% ç”»å¸ƒé«˜åº¦
                const scale = Math.min(scaleX, scaleY);

                console.log(`ğŸ” ç¼©æ”¾è®¡ç®—: scaleX=${scaleX.toFixed(2)}, scaleY=${scaleY.toFixed(2)}, final=${scale.toFixed(2)}`);

                // åº”ç”¨ç¼©æ”¾
                this.model.scale.set(scale);

                // å°†æ¨¡å‹æ”¾ç½®åœ¨ç”»å¸ƒæ­£ä¸­å¿ƒ
                this.model.x = canvasWidth / 2;
                this.model.y = canvasHeight / 2;

                // è·å–æœ€ç»ˆè¾¹ç•Œè¿›è¡ŒéªŒè¯
                const finalBounds = this.model.getBounds();
                
                console.log(`âœ“ æœ€ç»ˆæ¨¡å‹å®šä½:`);
                console.log(`  ä½ç½®: (${this.model.x}, ${this.model.y})`);
                console.log(`  ç¼©æ”¾: ${scale.toFixed(2)}`);
                console.log(`  æœ€ç»ˆè¾¹ç•Œ:`, {
                    x: finalBounds.x.toFixed(2),
                    y: finalBounds.y.toFixed(2),
                    width: finalBounds.width.toFixed(2),
                    height: finalBounds.height.toFixed(2)
                });

                // æ£€æŸ¥æ˜¯å¦åœ¨ç”»å¸ƒèŒƒå›´å†…
                const isInBounds = finalBounds.x >= 0 && 
                                 finalBounds.y >= 0 && 
                                 finalBounds.x + finalBounds.width <= canvasWidth &&
                                 finalBounds.y + finalBounds.height <= canvasHeight;
                                 
                console.log(`âœ“ æ¨¡å‹æ˜¯å¦å®Œå…¨åœ¨ç”»å¸ƒå†…: ${isInBounds}`);
            }

            createControls() {
                if (!this.modelSettings) return;

                this.createMotionButtons();
                this.createExpressionButtons();
            }

            createMotionButtons() {
                const motionContainer = document.getElementById('motion-buttons');
                const motions = this.modelSettings.motions;

                Object.keys(motions).forEach(group => {
                    motions[group].forEach((motion, index) => {
                        const button = document.createElement('button');
                        const fileName = motion.File.split('/').pop().replace('.motion3.json', '');
                        button.textContent = fileName;
                        button.className = 'control-btn';
                        
                        button.onclick = () => {
                            this.playMotion(group, index, fileName);
                        };
                        
                        motionContainer.appendChild(button);
                    });
                });
            }

            createExpressionButtons() {
                const expressionContainer = document.getElementById('expression-buttons');
                const expressions = this.modelSettings.expressions;

                expressions.forEach((expression, index) => {
                    const button = document.createElement('button');
                    const name = expression.Name || expression.File.split('/').pop().replace('.exp3.json', '');
                    button.textContent = name;
                    button.className = 'control-btn';
                    
                    button.onclick = () => {
                        this.playExpression(index, name);
                    };
                    
                    expressionContainer.appendChild(button);
                });
            }

            playMotion(group, index, fileName) {
                if (!this.model) {
                    console.warn('æ¨¡å‹æœªåŠ è½½ï¼Œæ— æ³•æ’­æ”¾åŠ¨ä½œ');
                    return;
                }

                try {
                    // ä½¿ç”¨å®˜æ–¹æ¨èçš„ API
                    this.model.motion(group, index, 3); // ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ä¼˜å…ˆçº§
                    console.log(`âœ“ æ’­æ”¾åŠ¨ä½œ: ç»„="${group}", ç´¢å¼•=${index}, æ–‡ä»¶=${fileName}`);
                } catch (error) {
                    console.error(`æ’­æ”¾åŠ¨ä½œå¤±è´¥: ${error.message}`);
                    // å¦‚æœæ–°APIå¤±è´¥ï¼Œå°è¯•æ—§APIä½œä¸ºå…œåº•
                    try {
                        this.model.internalModel.motionManager.startMotion(group, index, 3);
                        console.log(`âœ“ ä½¿ç”¨å…œåº•APIæ’­æ”¾åŠ¨ä½œ: ç»„="${group}", ç´¢å¼•=${index}`);
                    } catch (fallbackError) {
                        console.error(`å…œåº•APIä¹Ÿå¤±è´¥: ${fallbackError.message}`);
                    }
                }
            }

            playExpression(index, name) {
                if (!this.model) {
                    console.warn('æ¨¡å‹æœªåŠ è½½ï¼Œæ— æ³•æ’­æ”¾è¡¨æƒ…');
                    return;
                }

                try {
                    // ä½¿ç”¨å®˜æ–¹æ¨èçš„ API
                    this.model.expression(name || index);
                    console.log(`âœ“ æ’­æ”¾è¡¨æƒ…: ç´¢å¼•=${index}, åç§°=${name}`);
                } catch (error) {
                    console.error(`æ’­æ”¾è¡¨æƒ…å¤±è´¥: ${error.message}`);
                    // å¦‚æœæ–°APIå¤±è´¥ï¼Œå°è¯•æ—§APIä½œä¸ºå…œåº•
                    try {
                        this.model.internalModel.expressionManager.setExpression(index);
                        console.log(`âœ“ ä½¿ç”¨å…œåº•APIæ’­æ”¾è¡¨æƒ…: ç´¢å¼•=${index}`);
                    } catch (fallbackError) {
                        console.error(`å…œåº•APIä¹Ÿå¤±è´¥: ${fallbackError.message}`);
                    }
                }
            }

            resize() {
                if (!this.app) return;

                this.app.renderer.resize(window.innerWidth, window.innerHeight);
                this.positionModel();
            }

            async setupXiaozhiClient() {
                try {
                    // è®¾ç½®å›è°ƒå‡½æ•°
                    this.xiaozhiClient.onSttResult = (text) => {
                        console.log('ğŸ“ è¯­éŸ³è¯†åˆ«:', text);
                        // å¯ä»¥åœ¨è¿™é‡Œæ˜¾ç¤ºè¯†åˆ«ç»“æœ
                    };

                    this.xiaozhiClient.onLlmResponse = (text) => {
                        console.log('ğŸ¤– AIå›å¤:', text);
                        // å¼€å§‹è¯´è¯åŠ¨ä½œ
                        this.playTalk();
                    };

                    this.xiaozhiClient.onTtsUrl = async (url) => {
                        console.log('ğŸ”Š æ’­æ”¾TTS:', url);
                        try {
                            // åœæ­¢ä¹‹å‰çš„éŸ³é¢‘
                            this.stopCurrentTTS();
                            
                            // æ’­æ”¾æ–°çš„TTSéŸ³é¢‘
                            this.currentTTSAudio = new Audio(url);
                            this.currentTTSAudio.volume = 0.8;
                            
                            // éŸ³é¢‘ç»“æŸåå›åˆ°å¾…æœºçŠ¶æ€
                            this.currentTTSAudio.onended = () => {
                                console.log('ğŸ”Š TTSæ’­æ”¾å®Œæˆ');
                                this.playIdle();
                                this.currentTTSAudio = null;
                            };
                            
                            this.currentTTSAudio.onerror = (error) => {
                                console.error('ğŸ”Š TTSæ’­æ”¾å¤±è´¥:', error);
                                this.playIdle();
                                this.currentTTSAudio = null;
                            };
                            
                            await this.currentTTSAudio.play();
                            
                        } catch (error) {
                            console.error('æ’­æ”¾TTSéŸ³é¢‘å¤±è´¥:', error);
                            this.playIdle();
                        }
                    };

                    this.xiaozhiClient.onError = (error) => {
                        console.error('ğŸš¨ å°æ™ºå®¢æˆ·ç«¯é”™è¯¯:', error);
                        this.showError(`è¯­éŸ³åŠŸèƒ½é”™è¯¯: ${error.message}`);
                    };

                    // åˆå§‹åŒ–å°æ™ºå®¢æˆ·ç«¯
                    await this.xiaozhiClient.init();
                    
                    console.log('âœ“ å°æ™ºå®¢æˆ·ç«¯è®¾ç½®å®Œæˆ');
                } catch (error) {
                    console.error('è®¾ç½®å°æ™ºå®¢æˆ·ç«¯å¤±è´¥:', error);
                    // ä¸é˜»æ­¢åº”ç”¨å¯åŠ¨ï¼Œè¯­éŸ³åŠŸèƒ½å¯é€‰
                }
            }

            stopCurrentTTS() {
                if (this.currentTTSAudio) {
                    this.currentTTSAudio.pause();
                    this.currentTTSAudio.currentTime = 0;
                    this.currentTTSAudio = null;
                }
            }

            // å…¨å±€æ–¹æ³•ï¼šæ’­æ”¾è¯´è¯åŠ¨ä½œ
            playTalk() {
                if (!this.model) {
                    console.log('playTalk(): æ¨¡å‹æœªåŠ è½½');
                    return;
                }

                if (!this.modelSettings || !this.modelSettings.motions) {
                    console.log('playTalk(): æ¨¡å‹è®¾ç½®æœªæ‰¾åˆ°');
                    return;
                }

                const motions = this.modelSettings.motions;
                let talkMotion = null;
                let talkGroup = '';
                let talkIndex = -1;

                // åœ¨æ‰€æœ‰åŠ¨ä½œä¸­å¯»æ‰¾åŒ…å« talk æˆ– kaixin çš„
                Object.keys(motions).forEach(group => {
                    motions[group].forEach((motion, index) => {
                        const fileName = motion.File.toLowerCase();
                        if (fileName.includes('talk') || fileName.includes('kaixin')) {
                            talkMotion = motion;
                            talkGroup = group;
                            talkIndex = index;
                            return;
                        }
                    });
                });

                // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªåŠ¨ä½œ
                if (!talkMotion) {
                    const firstGroup = Object.keys(motions)[0];
                    if (firstGroup && motions[firstGroup].length > 0) {
                        talkMotion = motions[firstGroup][0];
                        talkGroup = firstGroup;
                        talkIndex = 0;
                    }
                }

                if (talkMotion) {
                    const fileName = talkMotion.File.split('/').pop().replace('.motion3.json', '');
                    this.playMotion(talkGroup, talkIndex, fileName);
                    console.log(`âœ“ playTalk() æ‰§è¡ŒæˆåŠŸ - ä½¿ç”¨åŠ¨ä½œ: ${fileName}`);
                } else {
                    console.log('playTalk(): æœªæ‰¾åˆ°å¯æ’­æ”¾çš„åŠ¨ä½œ');
                }
            }

            // å…¨å±€æ–¹æ³•ï¼šæ’­æ”¾å¾…æœºåŠ¨ä½œ
            playIdle() {
                if (!this.model) {
                    console.log('playIdle(): æ¨¡å‹æœªåŠ è½½');
                    return;
                }

                if (!this.modelSettings || !this.modelSettings.motions) {
                    console.log('playIdle(): æ¨¡å‹è®¾ç½®æœªæ‰¾åˆ°');
                    return;
                }

                const motions = this.modelSettings.motions;
                let idleMotion = null;
                let idleGroup = '';
                let idleIndex = -1;

                // å¯»æ‰¾ Idle ç»„æˆ–åŒ…å« idle çš„åŠ¨ä½œ
                Object.keys(motions).forEach(group => {
                    if (group.toLowerCase() === 'idle') {
                        if (motions[group].length > 0) {
                            idleMotion = motions[group][0];
                            idleGroup = group;
                            idleIndex = 0;
                            return;
                        }
                    }
                    
                    motions[group].forEach((motion, index) => {
                        const fileName = motion.File.toLowerCase();
                        if (fileName.includes('idle')) {
                            idleMotion = motion;
                            idleGroup = group;
                            idleIndex = index;
                            return;
                        }
                    });
                });

                if (idleMotion) {
                    const fileName = idleMotion.File.split('/').pop().replace('.motion3.json', '');
                    this.playMotion(idleGroup, idleIndex, fileName);
                    console.log(`âœ“ playIdle() æ‰§è¡ŒæˆåŠŸ - ä½¿ç”¨åŠ¨ä½œ: ${fileName}`);
                } else {
                    console.log('playIdle(): æœªæ‰¾åˆ° Idle å¾…æœºåŠ¨ä½œï¼Œå¿½ç•¥');
                }
            }
        }

        // ä½¿ç”¨ window.onload ç¡®ä¿æ‰€æœ‰èµ„æºåŠ è½½å®Œæˆ
        window.onload = () => {
            console.log('ğŸ“ é¡µé¢å’Œæ‰€æœ‰èµ„æºåŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...');
            try {
                window.live2dApp = new Live2DApp();
            } catch (error) {
                console.error('åº”ç”¨åˆå§‹åŒ–å¤±è´¥:', error);
                document.getElementById('loading-status').innerHTML = 
                    `<div style="color: #dc3545;">åˆå§‹åŒ–å¤±è´¥: ${error.message}</div>`;
            }
        };

        // æš´éœ²å…¨å±€æ–¹æ³•
        window.playTalk = () => {
            if (window.live2dApp && window.live2dApp.model) {
                window.live2dApp.playTalk();
            } else {
                console.log('åº”ç”¨æˆ–æ¨¡å‹æœªåŠ è½½å®Œæˆ');
            }
        };

        window.playIdle = () => {
            if (window.live2dApp && window.live2dApp.model) {
                window.live2dApp.playIdle();
            } else {
                console.log('åº”ç”¨æˆ–æ¨¡å‹æœªåŠ è½½å®Œæˆ');
            }
        };

        // é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
        window.addEventListener('beforeunload', () => {
            if (window.live2dApp && window.live2dApp.xiaozhiClient) {
                window.live2dApp.xiaozhiClient.disconnect();
            }
            if (window.live2dApp) {
                window.live2dApp.stopCurrentTTS();
            }
        });
    </script>
</body>
</html>

<!-- 
========== å¦‚ä½•å¯åŠ¨æœ¬åœ°æœåŠ¡å™¨ ==========

æ–¹æ³•1 - Python (æ¨è):
    python -m http.server 8000
    ç„¶åè®¿é—®: http://localhost:8000/

æ–¹æ³•2 - Node.js:
    npx http-server -p 8000
    ç„¶åè®¿é—®: http://localhost:8000/

æ–¹æ³•3 - VSCode Live Server:
    å®‰è£… Live Server æ’ä»¶ -> å³é”® index.html -> "Open with Live Server"

========== ä¸ºä»€ä¹ˆä¸èƒ½ç”¨ file:// ==========

ç›´æ¥åŒå‡» HTML æ–‡ä»¶ä¼šä½¿ç”¨ file:// åè®®ï¼Œè¿™ä¼šå¯¼è‡´:
- CORS ç­–ç•¥é˜»æ­¢åŠ è½½æœ¬åœ°èµ„æº (.json, .moc3 æ–‡ä»¶)
- æŸäº› Web API åœ¨ file:// ä¸‹ä¸å¯ç”¨
- Live2D æ¨¡å‹æ— æ³•æ­£å¸¸åŠ è½½

========== å¸¸è§é—®é¢˜è§£å†³ ==========

1. 404 é”™è¯¯:
   - æ£€æŸ¥æ–‡ä»¶è·¯å¾„å¤§å°å†™ (ç‰¹åˆ«æ˜¯ Linux/Mac ç³»ç»Ÿ)
   - ç¡®ä¿ Mould/ æ–‡ä»¶å¤¹å’Œæ¨¡å‹æ–‡ä»¶å­˜åœ¨
   - ç¡®ä¿ libs/live2dcubismcore.min.js å­˜åœ¨

2. CORS é”™è¯¯:
   - å¿…é¡»ä½¿ç”¨ HTTP æœåŠ¡å™¨ï¼Œä¸èƒ½ç›´æ¥æ‰“å¼€ HTML æ–‡ä»¶
   - æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦æ­£ç¡®è¿è¡Œ

3. æ¨¡å‹ä¸æ˜¾ç¤º:
   - æ‰“å¼€æµè§ˆå™¨æ§åˆ¶å°æŸ¥çœ‹é”™è¯¯ä¿¡æ¯
   - æ£€æŸ¥ HEAD è¯·æ±‚è¿”å›çŠ¶æ€ç 
   - ç¡®è®¤æ‰€æœ‰è„šæœ¬æ­£ç¡®åŠ è½½

4. MIME ç±»å‹é”™è¯¯:
   - ç¡®ä¿æœåŠ¡å™¨æ”¯æŒ .json, .moc3 ç­‰æ–‡ä»¶ç±»å‹
   - Python å’Œ Node.js çš„ http-server é€šå¸¸è‡ªåŠ¨å¤„ç†
-->